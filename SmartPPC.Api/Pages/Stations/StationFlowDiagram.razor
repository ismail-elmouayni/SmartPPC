@using SmartPPC.Core.Model.DDMRP

@{
    var stationPositions = CalculateStationPositions();
    var (svgWidth, svgHeight) = CalculateSvgDimensions(stationPositions);
}

<svg width="100%" height="@svgHeight" viewBox="0 0 @svgWidth @svgHeight" style="border: 1px solid #e0e0e0; background-color: white;">
    @if (Stations != null && Stations.Any())
    {

        @* Draw connections first (so they appear behind stations) *@
        @foreach (var station in Stations)
        {
            if (station.NextStationsInput != null && station.StationIndex.HasValue)
            {
                var fromPos = stationPositions.GetValueOrDefault(station.StationIndex.Value);
                @foreach (var next in station.NextStationsInput)
                {
                    var toPos = stationPositions.GetValueOrDefault(next.NextStationIndex);
                    if (fromPos != default && toPos != default)
                    {
                        var x1 = fromPos.X + 120;  // Right edge of source station
                        var y1 = fromPos.Y + 30;    // Middle of source station
                        var x2 = toPos.X;           // Left edge of target station
                        var y2 = toPos.Y + 30;      // Middle of target station

                        // Create curved path using cubic bezier
                        var controlPointOffset = Math.Abs(x2 - x1) * 0.5;
                        var cx1 = x1 + controlPointOffset;
                        var cy1 = y1;
                        var cx2 = x2 - controlPointOffset;
                        var cy2 = y2;

                        var pathData = $"M {x1} {y1} C {cx1} {cy1}, {cx2} {cy2}, {x2} {y2}";

                        <path d="@pathData"
                              stroke="#666"
                              stroke-width="2"
                              fill="none"
                              marker-end="url(#arrowhead)" />

                        @* Label for input amount *@
                        @((MarkupString)$"<text x=\"{(x1 + x2) / 2}\" y=\"{(y1 + y2) / 2 - 5}\" font-size=\"12\" fill=\"#666\" text-anchor=\"middle\">Ã—{next.InputAmount}</text>")
                    }
                }
            }
        }

        @* Draw stations *@
        @foreach (var station in Stations)
        {
            if (station.StationIndex.HasValue)
            {
                var pos = stationPositions.GetValueOrDefault(station.StationIndex.Value);
                var isSelected = station.StationIndex == SelectedStationIndex;
                var isOutput = station.DemandForecast != null && station.DemandForecast.Any();

                <g @onclick="@(() => OnStationClick(station.StationIndex.Value))" style="cursor: pointer;">
                    <rect x="@pos.X" y="@pos.Y" width="120" height="60"
                          fill="@(isSelected ? "#bb86fc" : isOutput ? "#03dac6" : "#6200ee")"
                          stroke="@(isSelected ? "#000" : "#333")"
                          stroke-width="@(isSelected ? 3 : 2)"
                          rx="5" />

                    @((MarkupString)$"<text x=\"{pos.X + 60}\" y=\"{pos.Y + 25}\" text-anchor=\"middle\" fill=\"white\" font-weight=\"bold\" font-size=\"14\">Station {station.StationIndex}</text>")

                    @((MarkupString)$"<text x=\"{pos.X + 60}\" y=\"{pos.Y + 45}\" text-anchor=\"middle\" fill=\"white\" font-size=\"11\">PT: {station.ProcessingTime}</text>")

                    @if (isOutput)
                    {
                        <circle cx="@(pos.X + 110)" cy="@(pos.Y + 10)" r="8" fill="#ff6b6b" />
                        @((MarkupString)$"<text x=\"{pos.X + 110}\" y=\"{pos.Y + 14}\" text-anchor=\"middle\" fill=\"white\" font-size=\"10\" font-weight=\"bold\">O</text>")
                    }
                </g>
            }
        }

        @* Arrow marker definition *@
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="#666" />
            </marker>
        </defs>
    }
    else
    {
        @((MarkupString)"<text x=\"400\" y=\"200\" text-anchor=\"middle\" fill=\"#999\" font-size=\"16\">No stations configured. Add a station to get started.</text>")
    }
</svg>

<div class="mt-2">
    <MudChip T="string" Size="MudSize.Small" Color="MudColor.Primary">Input Station</MudChip>
    <MudChip T="string" Size="MudSize.Small" Color="MudColor.Tertiary">Output Station</MudChip>
    <MudChip T="string" Size="MudSize.Small" Color="MudColor.Secondary">Selected</MudChip>
</div>

@code {
    [Parameter]
    public List<StationDeclaration>? Stations { get; set; }

    [Parameter]
    public EventCallback<int> OnStationSelected { get; set; }

    [Parameter]
    public int? SelectedStationIndex { get; set; }

    private Dictionary<int, int> AssignStationsToLayers()
    {
        var layers = new Dictionary<int, int>();

        if (Stations == null || !Stations.Any())
            return layers;

        // Build reverse adjacency list (who feeds into each station)
        var incomingEdges = new Dictionary<int, List<int>>();
        var allStationIndices = new HashSet<int>();

        foreach (var station in Stations.Where(s => s.StationIndex.HasValue))
        {
            var stationIdx = station.StationIndex!.Value;
            allStationIndices.Add(stationIdx);

            if (!incomingEdges.ContainsKey(stationIdx))
                incomingEdges[stationIdx] = new List<int>();

            if (station.NextStationsInput != null)
            {
                foreach (var next in station.NextStationsInput)
                {
                    if (!incomingEdges.ContainsKey(next.NextStationIndex))
                        incomingEdges[next.NextStationIndex] = new List<int>();
                    incomingEdges[next.NextStationIndex].Add(stationIdx);
                }
            }
        }

        // Find input stations (no incoming edges)
        var inputStations = allStationIndices.Where(idx =>
            !incomingEdges.ContainsKey(idx) || !incomingEdges[idx].Any()).ToList();

        // Assign layers using BFS
        var queue = new Queue<int>();
        foreach (var inputStation in inputStations)
        {
            layers[inputStation] = 0;
            queue.Enqueue(inputStation);
        }

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var currentLayer = layers[current];
            var currentStation = Stations.FirstOrDefault(s => s.StationIndex == current);

            if (currentStation?.NextStationsInput != null)
            {
                foreach (var next in currentStation.NextStationsInput)
                {
                    var nextIdx = next.NextStationIndex;
                    var newLayer = currentLayer + 1;

                    if (!layers.ContainsKey(nextIdx) || layers[nextIdx] < newLayer)
                    {
                        layers[nextIdx] = newLayer;
                        queue.Enqueue(nextIdx);
                    }
                }
            }
        }

        return layers;
    }

    private Dictionary<int, int> CalculateVerticalPositions(Dictionary<int, int> layers)
    {
        var verticalPositions = new Dictionary<int, int>();

        if (Stations == null || !Stations.Any())
            return verticalPositions;

        const int stationHeight = 60;
        const int verticalSpacing = 72; // 60 + 20% margin

        // Group stations by layer
        var stationsByLayer = layers.GroupBy(kvp => kvp.Value)
            .OrderBy(g => g.Key)
            .ToDictionary(g => g.Key, g => g.Select(kvp => kvp.Key).ToList());

        // Assign vertical positions layer by layer
        foreach (var layer in stationsByLayer.Keys.OrderBy(k => k))
        {
            var stationsInLayer = stationsByLayer[layer];
            var layerHeight = stationsInLayer.Count * verticalSpacing;
            var startY = 0;

            // If this is not the first layer, try to position stations relative to their predecessors
            if (layer > 0)
            {
                var predecessorPositions = new List<int>();
                foreach (var stationIdx in stationsInLayer)
                {
                    var station = Stations.FirstOrDefault(s => s.StationIndex == stationIdx);
                    // Find all stations that feed into this one
                    var predecessors = Stations
                        .Where(s => s.NextStationsInput != null &&
                               s.NextStationsInput.Any(n => n.NextStationIndex == stationIdx) &&
                               verticalPositions.ContainsKey(s.StationIndex!.Value))
                        .Select(s => verticalPositions[s.StationIndex!.Value])
                        .ToList();

                    if (predecessors.Any())
                        predecessorPositions.Add((int)predecessors.Average());
                }

                if (predecessorPositions.Any())
                    startY = predecessorPositions.Min() - (stationsInLayer.Count / 2) * verticalSpacing;
            }

            for (int i = 0; i < stationsInLayer.Count; i++)
            {
                verticalPositions[stationsInLayer[i]] = startY + i * verticalSpacing;
            }
        }

        return verticalPositions;
    }

    private (int Width, int Height) CalculateSvgDimensions(Dictionary<int, (int X, int Y)> positions)
    {
        if (positions.Count == 0)
            return (800, 400);

        const int padding = 100;
        const int stationWidth = 120;
        const int stationHeight = 60;

        var maxX = positions.Values.Max(p => p.X) + stationWidth + padding;
        var maxY = positions.Values.Max(p => p.Y) + stationHeight + padding;
        var minY = positions.Values.Min(p => p.Y);

        var height = maxY - minY + padding;

        return (maxX, Math.Max(400, height));
    }

    private Dictionary<int, (int X, int Y)> CalculateStationPositions()
    {
        var positions = new Dictionary<int, (int X, int Y)>();

        if (Stations == null || !Stations.Any())
            return positions;

        // Step 1: Assign stations to horizontal layers
        var layers = AssignStationsToLayers();

        // Step 2: Calculate vertical positions
        var verticalPositions = CalculateVerticalPositions(layers);

        // Step 3: Combine into final positions
        const int horizontalSpacing = 200;
        const int startX = 50;
        const int startY = 50;

        // Find the minimum vertical position to offset everything
        var minY = verticalPositions.Values.Any() ? verticalPositions.Values.Min() : 0;
        var yOffset = startY - minY;

        foreach (var stationIdx in layers.Keys)
        {
            var layer = layers[stationIdx];
            var vPos = verticalPositions.GetValueOrDefault(stationIdx, 0);

            positions[stationIdx] = (
                startX + layer * horizontalSpacing,
                vPos + yOffset
            );
        }

        return positions;
    }

    private async Task OnStationClick(int stationIndex)
    {
        await OnStationSelected.InvokeAsync(stationIndex);
    }
}
